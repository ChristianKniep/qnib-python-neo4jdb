#! /usr/bin/env python
# -*- coding: utf-8 -*-

import time
import re
from pprint import pprint
# extra libs
from neo4jrestclient.client import GraphDatabase, Node
from neo4jrestclient.query import QuerySequence
from requests.exceptions import ConnectionError
from qnib_graphdb import GraphDB
from ClusterShell.NodeSet import NodeSet

class N4jDB(GraphDB):
    def __init__(self, cfg):
        super(N4jDB, self).__init__(cfg)

    def con_gdb(self):
        """ connect to neo4j
        """
        try:
            url = "http://%(--neo4j-host)s:7474" % self._cfg
        except:
            url = "http://%(--host)s:7474" % self._cfg
        try:
            self._gdb = GraphDatabase(url)
        except ConnectionError:
            time.sleep(3)
            self.con_gdb()

    def create_node(self, node):
        """
        :param node: dict with node information

        """
        # FIXME: This is not quite right for now, since the lid is provided by the node, even though it
        # should be part of the port information, since a node could have multiple ports, hence
        # multiple lids.
        query = "MERGE (n:%(Type)s {guid:'%(Guid)s', name:'%(Name)s', lids:['%(Lid)s']}) " % node
        port_cnt = int(node['Guid'][2:], 16)
        for pnr in range(1, node['Ports'] + 1):
            port_cnt += 1
            if node['Type'] == 'SW':
                pguid = node['Guid']
            else:
                pguid = "0x%x" % port_cnt
            query += " MERGE (n)<-[:PART_OF]-(p%s:PORT {guid:'%s', port_int:'%s', lid:'%s'})" % (pnr, pguid, pnr, node['Lid'])
        self._gdb.query(query)
        msg = "Made sure node with guid '%(Guid)s' is in graph" % node
        self._cfg._logger.debug(msg)

    def merge_link(self, link, link_type):
        if link_type in ("ASICLinkList", "ASICList"):
            # Since we only have to catch SW<>SW connection we assume:
            # - looking for a SW-PORT which has the same GUID for each switch
            # - port_int determines which port to choose
            self.merge_hca_link(link)
        elif link_type in ("HCALinkList", "HCAList"):
            # a link originating from a HCA can only link to a switch...
            self.merge_sw_link(link)

    def merge_hca_link(self, link):
        """
        :param link: dict with link information
        :return:
        """
        query = "MATCH (src)<-[:PART_OF]-(sp:PORT {guid:'%(src_guid)s', port_int:'%(src_port)s'})," % link
        query += " (dest)<-[:PART_OF]-(dp:PORT {guid:'%(dst_guid)s', port_int:'%(dst_port)s'})" % link
        query += " MERGE (sp)<-[:CON]-(dp) MERGE (sp)-[:CON]->(dp)"
        query += " MERGE (src)<-[:LINKED]-(dest) MERGE (src)-[:LINKED]->(dest)"
        self._cfg._logger.debug(query)
        self._gdb.query(query, params=link)

    def merge_sw_link(self, link):
        query = "MATCH (src)<-[:PART_OF]-(sp:PORT {guid:'%(src_guid)s', port_int:'%(src_port)s'})," % link
        query += " (dest)<-[:PART_OF]-(dp:PORT {guid:'%(dst_guid)s', port_int:'%(dst_port)s'})" % link
        query += " MERGE (sp)<-[:CON]-(dp) MERGE (sp)-[:CON]->(dp)"
        query += " MERGE (src)<-[:LINKED]-(dest) MERGE (src)-[:LINKED]->(dest)"
        self._cfg._logger.debug(query)
        self._gdb.query(query, params=link)

    def merge_route(self, route):
        if route['dst_type'] == "HCA":
            # Since the destination is a HCA, we assume we are originating from an SW
            # -> Hence, ports have the same GUID, the port_int distinguishes
            query = "MATCH (dp:PORT {guid:'%(dst_guid)s'})-[:PART_OF]->(dn:%(dst_type)s)," % route
            query += " (sp:PORT {guid:'%(src_guid)s', port_int:'%(out_port)s'})" % route
            query += " MERGE (sp)-[:ROUTE_TO]->(dn)"
        else:
            # If the destination is a SW, only a SW source is of interest, since the port of an HCA is
            # only connected to one switch its the gateway to every destination
            query = "MATCH (dn:%(dst_type)s {guid:'%(dst_guid)s'})," % route
            query += " (sp:PORT {guid:'%(src_guid)s', port_int:'%(out_port)s'})" % route
            query += " MERGE (sp)-[:ROUTE_TO]->(dn)"
        self._cfg._logger.debug(query)
        self._gdb.query(query, params=route)

    def merge_slurm_partition(self, partition, nodeset):
        """
        :param partition: Name of partition
        :param nodeset: clustershell format of nodenames (e.g. compute[0-6])
        """
        query = "MATCH (n:HCA) WHERE n.name =~ '(%s).*'" % "|".join(NodeSet(nodeset))
        query += " MERGE (p:SlurmPartition {name:'%s'})" % partition
        query += " MERGE (n)-[:MEMBER]->(p)"
        self._gdb.query(query)

    def merge_slurm_job(self, jobinfo):
        """ Puts job information in cluster
        """
        query = " MERGE (j:SlurmJob {id: '%(JobId)s', name:'%(Name)s', batch: '%(BatchFlag)s', command: '%(Command)s'})" % jobinfo
        query += "ON CREATE SET j.created=timestamp(), j.seen=timestamp(), j.state='%(JobState)s'" % jobinfo
        query += "ON MATCH SET j.seen=timestamp(), j.started='%(StartTime)s', j.state='%(JobState)s'" % jobinfo
        self._gdb.query(query)
        query = "MATCH (n:HCA) WHERE n.name =~ '(%s).*'" % "|".join(NodeSet(jobinfo['NodeList']))
        query += " MATCH (b:HCA) WHERE b.name =~ '%(BatchHost)s.*'" % jobinfo
        query += " MATCH (j:SlurmJob {id: '%(JobId)s'})" % jobinfo
        query += " MERGE (b)-[:JOBMASTER]-(j)"
        query += " MERGE (n)-[:JOBCLIENT]->(j)"
        self._gdb.query(query)

    def get_slurm_partitions(self):
        """ get partition information
        """
        query = "MATCH (p:SlurmPartition)<-[:MEMBER]-(h) RETURN p, h"
        res = self._gdb.query(query, data_contents=True)
        for row in res.graph:
            print row


    def unfold(self, res):
        if isinstance(res, QuerySequence) and len(res._elements) >= 2:
            return res[0]
        if isinstance(res, QuerySequence) and len(res) == 1:
            return res[0][0]
        if isinstance(res, list):
            ret = res.pop()
            self.unfold(ret)
        else:
            if isinstance(res, QuerySequence):
                return None
            return res

    def node_by_lid(self, lid):
        """ fetch node using lid
        """
        query = "MATCH (n {lid:'%s'}) RETURN n" % lid
        self._cfg._logger.debug(query)
        res = self._gdb.query(query, returns=(Node))
        node = {}
        if len(res) > 0:
            node['src_node_name'] = res[0][0]['name']
            node['src_lid'] = res[0][0]['lid']
        return node

    def node_by_guid(self, msg):
        """ fetch node using lid
        """
        query = "MATCH (n {guid: '%(src_node_guid)s'}) RETURN n" % msg
        self._cfg._logger.info(query)
        res = self._gdb.query(query, returns=Node)
        node = {}
        if len(res) > 0:
            node['src_node_name'] = res[0][0]['name']
            node['src_lid'] = res[0][0]['lid']
        else:
            return None
        return node

    def get_node_by_port(self, msg):
        """
        :param msg: dict with message information (among them src_port_guid)
        :return: enrichted dict
        """
        ## if it's an HCA port_guid
        try:
            query = "MATCH ()-[:CON]-(p)-[:PART_OF]->(n:HCA {guid: '%(src_port_guid)s'}) RETURN n,p" % msg
        except KeyError:
            pprint(msg)
            raise
        self._cfg._logger.info(query)
        res = self._gdb.query(query, returns=Node)
        node = {}
        if len(res) > 0:
            node['src_type'] = "HCA"
            node['src_node_name'] = res[0][0]['name']
            node['src_lid'] = res[0][0]['lid']
            node['src_port_int'] = res[0][1]['data']['port_int']
        else:
            # must be a switch
            query = "MATCH (s:SW {guid: '%(src_port_guid)s'}) RETURN s" % msg
            self._cfg._logger.info(query)
            res = self._gdb.query(query, returns=Node)
            node['src_type'] = "SW"
            node['src_node_name'] = res[0][0]['name']
            node['src_lid'] = res[0][0]['lid']
            node['src_port_int'] = '0'
        return node

    def fetch_topology(self):
        """ queries GraphDB to get topology
        """
        query = "MATCH (s)-[l:LINKED]-(d) RETURN s, l, d"
        res = self._gdb.query(query, data_contents=True)
        topo_cache = set([])
        topo = []
        for row in res.graph:
            src, dest = row['nodes']
            clean_src = {
                'name': src['properties']['name'],
                'guid': src['properties']['guid'],
                'label': ",".join(src['labels'])
                }
            clean_dest = {
                'name': dest['properties']['name'],
                'guid': dest['properties']['guid'],
                'label': ",".join(dest['labels'])
            }
            key = "%s_%s" % tuple(sorted([clean_src['guid'], clean_dest['guid']]))
            if key not in topo_cache:
                topo_cache.add(key)
                topo.append((clean_src, clean_dest))
        return topo